<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visual Debugger</title>
    <script type="text/javascript" src="{{vis-network.min.js}}"></script>
    <script type="text/javascript" src="{{ffmpeg.min.js}}"></script>
    <script type="module" src="{{toolkit.min.js}}"></script>
    <link href="{{visjsDebuggerPanel.css}}" rel="stylesheet" />
    <link href="{{codicon.css}}" rel="stylesheet" />
  </head>

  <body>
    <div class="container">
      <div id="visjs-network"></div>
      <div class="top-row">
        <vscode-button class="progress-button" appearance="icon" onclick="stepBack()" aria-label="Show previous step">
          <span class="codicon codicon-debug-reverse-continue"></span>
        </vscode-button>
        <vscode-button class="progress-button" appearance="icon" onclick="stepForward()" aria-label="Show next step">
          <span class="codicon codicon-debug-continue"></span>
        </vscode-button>
        <vscode-dropdown id="stackFramesDropdown" class="stack-frames-dropdown"></vscode-dropdown>
      </div>
    </div>

    <script type="text/javascript">
      let network;
      let edges;
      let nodes;
      let defaultNodeColor;
      let defaultEdgeColor;
      let recorder;
      let chunks;
      let vscode;
      let canvas;
      let dropdown;

      window.addEventListener('message', (event) => {
        const message = event.data;
        switch (message.command) {
          case 'initializeVisjs':
            initializeVisjs(message);
            break;
          case 'updateVisjs':
            updateVisjs(message);
            break;
          case 'exportVisjs':
            exportVisjs();
            break;
          case 'startRecordingVisjs':
            startRecordingVisjs();
            break;
          case 'stopRecordingVisjs':
            stopRecordingVisjs();
            break;
          case 'updateStackFrames':
            updateStackFrames(message);
            break;
          default:
            console.debug(message.command);
        }
      });

      function initializeVisjs(message) {
        const container = document.querySelector('#visjs-network');
        edges = new vis.DataSet(message.data.edges);
        nodes = new vis.DataSet(message.data.nodes);
        defaultNodeColor = message.options.nodes.color;
        defaultEdgeColor = message.options.edges.color;
        const data = {
          edges,
          nodes,
        };
        network = new vis.Network(container, data, message.options);
        vscode = acquireVsCodeApi();
        canvas = document.querySelector('#visjs-network canvas');
      }

      function updateVisjs(message) {
        edges.remove(message.data.deleteEdgeIds);
        nodes.remove(message.data.deleteNodeIds);
        nodes.updateOnly(
          nodes.map((node) => ({
            ...node,
            color: defaultNodeColor,
          }))
        );
        edges.updateOnly(
          edges.map((edge) => ({
            ...edge,
            color: defaultEdgeColor,
          }))
        );
        nodes.add(message.data.addNodes);
        nodes.updateOnly(message.data.updateNodes);
        edges.add(message.data.addEdges);
      }

      function exportVisjs() {
        if (canvas) {
          const img = canvas.toDataURL('image/png');
          downloadFile('export.png', img);
        }
      }

      function startRecordingVisjs() {
        if (canvas) {
          chunks = [];
          const stream = canvas.captureStream();
          recorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9',
            ignoreMutedMedia: true,
          });
          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };
          recorder.start();
        }
      }

      function stopRecordingVisjs() {
        if (vscode) {
          recorder.stop();
          vscode.postMessage({ command: 'creatingGif' });
          setTimeout(() => {
            const blob = new Blob(chunks, {
              type: 'video/webm',
            });
            const webmVideo = URL.createObjectURL(blob);
            convertWebmToGif(webmVideo);
          }, 0);
        }
      }

      function convertWebmToGif(file) {
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({
          corePath: '{{ffmpeg-core.js}}',
          log: true,
        });
        (async () => {
          await ffmpeg.load();
          ffmpeg.FS('writeFile', 'export.webm', await fetchFile(file));
          await ffmpeg.run('-i', 'export.webm', 'export.gif');
          const data = ffmpeg.FS('readFile', 'export.gif');
          var gifVideo = URL.createObjectURL(
            new Blob([data.buffer], {
              type: 'image/gif',
            })
          );
          downloadFile('export.gif', gifVideo);
        })();
      }

      function downloadFile(filename, file) {
        var downloadLink = document.createElement('a');
        downloadLink.download = filename;
        downloadLink.href = file;
        downloadLink.click();
      }

      function stepBack() {
        vscode?.postMessage({ command: 'stepBack' });
      }

      function stepForward() {
        vscode?.postMessage({ command: 'stepForward' });
      }

      function updateStackFrames(message) {
        if (!dropdown) {
          setupStackFramesDropdown();
        }
        dropdown.innerHTML = '';
        const stackFrames = message.stackFrames;
        for (let i = 0; i < stackFrames.length; i++) {
          const frame = stackFrames[i];
          const option = document.createElement('vscode-option');
          option.value = i;
          option.innerHTML = frame;
          dropdown.appendChild(option);
        }
      }

      function setupStackFramesDropdown() {
        dropdown = document.querySelector('#stackFramesDropdown');
        dropdown.addEventListener('change', (element) => {
          const stackFrameIndex = element.srcElement.value;
          vscode.postMessage({ command: 'selectStackFrame', content: stackFrameIndex });
        });
      }
    </script>
  </body>
</html>
