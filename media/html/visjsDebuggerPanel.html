<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visual Debugger</title>
    <script type="text/javascript" src="{{vis-network.min.js}}"></script>
    <script type="text/javascript" src="{{LZWEncoder.js}}"></script>
    <script type="text/javascript" src="{{NeuQuant.js}}"></script>
    <script type="text/javascript" src="{{GIFEncoder.js}}"></script>
    <script type="module" src="{{toolkit.min.js}}"></script>
    <link href="{{visjsDebuggerPanel.css}}" rel="stylesheet" />
    <link href="{{codicon.css}}" rel="stylesheet" />
  </head>

  <body>
    <div class="container">
      <div id="visjs-network"></div>
      <div class="top-row">
        <vscode-button class="progress-button" appearance="icon" onclick="stepBack()" aria-label="Show previous step">
          <span class="codicon codicon-debug-reverse-continue"></span>
        </vscode-button>
        <vscode-button class="progress-button" appearance="icon" onclick="stepForward()" aria-label="Show next step">
          <span class="codicon codicon-debug-continue"></span>
        </vscode-button>
        <vscode-dropdown id="stackFramesDropdown" class="stack-frames-dropdown"></vscode-dropdown>
        <vscode-button class="open-all-clusters-button" appearance="icon" onclick="openAllClusters()" aria-label="Open all clusters">
          <span class="codicon codicon-type-hierarchy"></span>
        </vscode-button>
      </div>
    </div>

    <script type="text/javascript">
      let network;
      let edges;
      let nodes;
      let defaultNodeColor;
      let defaultEdgeColor;
      let gifFrames;
      let gifFrameCount;
      let gifRecording;
      let recorder;
      let chunks;
      let vscode;
      let canvas;
      let dropdown;
      let emptyOption;

      window.addEventListener('message', (event) => {
        const message = event.data;
        switch (message.command) {
          case 'initializeVisjs':
            initializeVisjs(message);
            break;
          case 'updateVisjs':
            updateVisjs(message);
            break;
          case 'exportVisjs':
            exportVisjs();
            break;
          case 'startRecordingVisjsGif':
            startRecordingVisjsGif();
            break;
          case 'startRecordingVisjsWebm':
            startRecordingVisjsWebm();
            break;
          case 'stopRecordingVisjsGif':
            stopRecordingVisjsGif();
            break;
          case 'stopRecordingVisjsWebm':
            stopRecordingVisjsWebm();
            break;
          case 'updateStackFrames':
            updateStackFrames(message);
            break;
          case 'deselectStackFrames':
            deselectStackFrames();
            break;
          default:
            console.debug(message.command);
        }
      });

      function initializeVisjs(message) {
        const container = document.querySelector('#visjs-network');
        edges = new vis.DataSet(message.data.edges);
        nodes = new vis.DataSet(message.data.nodes);
        defaultNodeColor = message.options.nodes.color;
        defaultEdgeColor = message.options.edges.color;
        const data = {
          edges,
          nodes,
        };
        network = new vis.Network(container, data, message.options);
        vscode = vscode ?? acquireVsCodeApi();
        canvas = document.querySelector('#visjs-network canvas');

        network.on('selectNode', function (params) {
          if (params.nodes.length === 1) {
            const node = params.nodes[0];
            if (network.isCluster(node)) {
              network.openCluster(node);
            } else if (node.startsWith('variable_')) {
              clusterNodes(node);
            } else {
              clusterChildNodes(node);
            }
          }
        });
      }

      function clusterChildNodes(id) {
        const nodeList = new Set([id]);
        childNodes = network.getConnectedNodes(id, 'to');
        childNodes.forEach((childNode) => {
          nodeList.add(childNode);
          getAllConnectingNodes(childNode, nodeList);
        });
        clusterNodes(id, nodeList);
      }

      function getAllConnectingNodes(id, nodeList) {
        const children = network.getConnectedNodes(id).filter((nodeId) => !nodeList.has(nodeId));
        if (children.length !== 0) {
          children.forEach((child) => {
            nodeList.add(child);
            getAllConnectingNodes(child, nodeList);
          });
        }
        return nodeList;
      }

      function clusterNodes(id, nodeList) {
        const joinConditionNodes = (nodeOptions) => nodeList.has(nodeOptions.id);

        const options = {
          joinCondition: nodeList != undefined ? joinConditionNodes : undefined,
          processProperties: (clusterOptions) => {
            clusterOptions.id = 'cluster_' + id;
            clusterOptions.label = nodes.get(id).label;
            return clusterOptions;
          },
          clusterNodeProperties: {
            borderWidth: 5,
          },
        };
        if (nodeList != undefined) {
          network.cluster(options);
        } else {
          network.clusterByConnection(id, options);
        }
      }

      function updateVisjs(message) {
        edges.remove(message.data.deleteEdgeIds);
        nodes.remove(message.data.deleteNodeIds);
        nodes.updateOnly(
          nodes.map((node) => ({
            ...node,
            color: defaultNodeColor,
          }))
        );
        edges.updateOnly(
          edges.map((edge) => ({
            ...edge,
            color: defaultEdgeColor,
          }))
        );
        const edgesClusterStack = getEdgesClusterStack(message);
        nodes.add(message.data.addNodes);
        nodes.updateOnly(message.data.updateNodes);
        edges.add(message.data.addEdges);
        reCluster(edgesClusterStack);
      }

      function getEdgesClusterStack(message) {
        const edgesClusterStack = [];
        message.data.addEdges.forEach((edge) => {
          if (network.findNode(edge.from).length > 1 || network.findNode(edge.to) > 1) {
            edgesClusterStack.push({ fromCluster: network.findNode(edge.from), toCluster: network.findNode(edge.to) });
          }
        });
        return edgesClusterStack;
      }

      function reCluster(edgesClusterStack) {
        edgesClusterStack.forEach((edge) => {
          if (edge.fromCluster.length < edge.toCluster.length) {
            openClusterStack(edge.fromCluster.filter((cluster) => !edge.toCluster.includes(cluster)));
            updateCluster(edge.toCluster);
          } else {
            openClusterStack(edge.toCluster.filter((cluster) => !edge.fromCluster.includes(cluster)));
            updateCluster(edge.fromCluster);
          }
        });
      }

      function openClusterStack(clusterStack) {
        clusterStack.forEach((cluster) => {
          if (nodes.get(cluster) !== undefined && network.isCluster(cluster)) {
            network.openCluster(cluster);
          }
        });
      }

      function updateCluster(clusterStack) {
        if (clusterStack.length >= 1) {
          if (clusterStack[0] !== undefined && network.isCluster(clusterStack[0])) {
            const clusterNodeId = clusterStack[0].substring(8);
            network.openCluster(clusterStack[0]);

            clusterStack.shift();
            updateCluster(clusterStack);

            if (clusterNodeId.startsWith('variable_')) {
              clusterNodes(clusterNodeId);
            } else {
              clusterChildNodes(clusterNodeId);
            }
          } else {
            clusterStack.shift();
            updateCluster(clusterStack);
          }
        }
      }

      function exportVisjs() {
        if (canvas) {
          const img = canvas.toDataURL('image/png');
          downloadFile('export.png', img);
        }
      }

      function startRecordingVisjsGif() {
        if (canvas) {
          gifFrames = [];
          gifFrameCount = 0;
          gifRecording = true;
          count = 0;
          encoder = new GIFEncoder();
          encoder.setRepeat(0); 
          encoder.setQuality(20);
          encoder.setDelay(90); 
          encoder.setSize(canvas.width, canvas.height);
          window.requestAnimationFrame(drawFrame);
          encoder.start();
        }
      }

      function startRecordingVisjsWebm() {
        if (canvas) {
          chunks = [];
          const stream = canvas.captureStream();
          recorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9',
            ignoreMutedMedia: true,
          });
          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };
          recorder.start();
        }
      }

      function stopRecordingVisjsGif(render) {
        if (vscode) {
          gifRecording = false;
          vscode.postMessage({ command: 'creatingGif'});
          gifFrames.forEach(gifFrame => {
            encoder.addFrame(gifFrame,true);
          });

          encoder.finish();
          encoder.download("export.gif");
        }
      }

      function stopRecordingVisjsWebm(render) {
        if (vscode) {
          recorder.stop();
          setTimeout(() => {
            const blob = new Blob(chunks, {
              type: 'video/webm',
            });
            downloadFile('export.webm',URL.createObjectURL(blob));
          }, 0);
        }
      }

      function drawFrame(){
        if(gifRecording){
          if(gifFrameCount % 3 === 0) {
            gifFrames.push(canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height).data);
          }
          gifFrameCount++;
          window.requestAnimationFrame(drawFrame);
        }
      }

      function downloadFile(filename, file) {
        var downloadLink = document.createElement('a');
        downloadLink.download = filename;
        downloadLink.href = file;
        downloadLink.click();
      }

      function stepBack() {
        vscode?.postMessage({ command: 'stepBack' });
      }

      function stepForward() {
        vscode?.postMessage({ command: 'stepForward' });
      }

      function updateStackFrames(message) {
        if (!dropdown) {
          setupStackFramesDropdown();
        }
        dropdown.innerHTML = '';
        const stackFrames = message.stackFrames;
        for (let i = 0; i < stackFrames.length; i++) {
          const frame = stackFrames[i];
          const option = document.createElement('vscode-option');
          option.value = i;
          option.innerHTML = frame;
          dropdown.appendChild(option);
        }
        dropdown.appendChild(emptyOption);
      }

      function setupStackFramesDropdown() {
        dropdown = document.querySelector('#stackFramesDropdown');
        dropdown.addEventListener('change', (element) => {
          const stackFrameIndex = element.srcElement.value;
          vscode.postMessage({ command: 'selectStackFrame', content: stackFrameIndex });
        });

        emptyOption = document.createElement('vscode-option');
        emptyOption.innerHTML = '';
        emptyOption.value = '';
        emptyOption.disabled = true;
        emptyOption.hidden = true;
      }

      function deselectStackFrames() {
        dropdown.value = '';
      }

      function openAllClusters() {
        openClusterStack(
          Object.keys(network.body.nodes).filter((nodeId) => {
            return nodeId.startsWith('cluster_');
          })
        );
      }
    </script>
  </body>
</html>
